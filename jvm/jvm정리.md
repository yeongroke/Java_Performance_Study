## JVM
### 자바 가상 머신(Java Virtual Machine)
### 시스템 메모리를 관리하면서, 자바 기반 애플리케이션을 위해 이식 가능한 실행 환경을 제공함
### 다른 의미로는 Java Byte Code를 다양한 OS에 맞게 해석을 해주는 역할을 한다.
<br>

<img src="https://user-images.githubusercontent.com/42057185/168136290-af2488e9-b9d4-4aa0-bec9-eea45e4903fa.png"/>
<br>

### JVM은, 다른 프로그램을 실행시키는 것이 목적이다.
#### 갖춘 기능으로는 크게 2가지로 말할 수 있다.
#### 1. 자바 프로그램이 어느 기기나 운영체제 상에서도 실행될 수 있도록 하는 것
#### 2. 프로그램 메모리를 관리하고 최적화하는 것
#### JVM은 코드를 실행하고, 해당 코드에 대해 런타임 환경을 제공하는 프로그램에 대한 사양임
<br>

### 자바 컴파일러의 문제점 및 해결방법?
#### JVM은 OS가 Java Byte Code를 이해할 수 있도록 해석을 해준다, 하지만 JVM의 해석을 거치기 때문에 C언어 같은 네이티브 언어에 비해서 속도가 현저히 느렸지만 JIT(Just In Time) 컴파일러를 구현하여 이 문제점을 극복하였다.
<br>

#### 개발자들이 말하는 JVM은 보통 어떤 기기상에서 실행되고 있는 프로세스, 특히 자바 앱에 대한 리소스를 대표하고 통제하는 서버를 지칭한다.
#### 자바 애플리케이션을 클래스 로더를 통해 읽어들이고, 자바 API와 함께 실행하는 역할. JAVA와 OS 사이에서 중개자 역할을 수행하여 OS에 구애받지 않고 재사용을 가능하게 해준다.
<br>

#### JVM에서의 메모리 관리
<br>
<br>

### JVM 실행에 있어서 가장 일반적인 상호작용은, 힙과 스택의 메모리 사용을 확인하는 것
#### 실행 과정
#### 1. 프로그램이 실행되면, JVM은 OS로부터 이 프로그램이 필요로하는 메모리를 할당받음. JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리함
#### 2. 자바 컴파일러(JAVAC)가 자바 소스코드를 읽고, 자바 바이트코드(.class)로 변환시킴
#### 3. 변경된 class 파일들을 클래스 로더를 통해 JVM 메모리 영역으로 로딩함
#### 4. 로딩된 class파일들은 Execution engine을 통해 해석됨
#### 5. 해석된 바이트 코드는 메모리 영역에 배치되어 실질적인 수행이 이루어짐. 이러한 실행 과정 속 JVM은 필요에 따라 스레드 동기화나 가비지 컬렉션 같은 메모리 관리 작업을 수행함
<br>

<img src="https://user-images.githubusercontent.com/42057185/168136425-edc8a59a-2c6f-4652-b99d-bdbf6f005b9b.png"/>
<br>


##  자바 컴파일러
### 자바 소스코드(.java)를 바이트 코드(.class)로 변환시켜줌
<br>

## 클래스 로더
### JVM은 런타임시에 처음으로 클래스를 참조할 때 해당 클래스를 로드하고 메모리 영역에 배치시키는 모듈로써 런타임시에 동적으로 클래스를 로드한다.
<br>

## Runtime Data Areas
## JVM이 운영체제 위에서 실행되면서 할당받는 메모리 영역임
### 총 5가지 영역으로 나누어짐 : PC 레지스터, JVM 스택, 네이티브 메서드 스택, 힙, 메서드 영역
### (이 중에 힙과 메서드 영역은 모든 스레드가 공유해서 사용함)
<br>

### PC 레지스터
#### 스레드가 어떤 명령어로 실행되어야 할지 기록하는 부분(현재 수행중인 JVM 명령의 주소를 가짐)
#### 프로그램 실행은 CPU에서 지시(Instruction)명령어를 수행할 때
#### CPU가 Instruction을 수행하는 동안 필요한 정보를 CPU 내 기억장치 레지스터에 저장
<br>

### Stack Area
#### 지역변수, 매개변수, 메서드 정보, 임시 데이터 등을 저장
#### 각 스레드마다 하나씩 존재하며, 스레드가 시작될 때 할당
#### 기본(원시) 타입 변수는 Stack Area에 직접 값을 가진다.
#### 참조타입 변수는 힙 영역이나 Method Area의 객체 주소를 가진다.
<br>

### 네이티브 메서드 스택
#### 실제 실행할 수 있는 기계어로 작성된 프로그램을 실행시키는 영역
#### 즉, JNI(Java Native Interface)를 통해 호출되는 C/C++ 등의 코드를 수행하기 위한 스택
#### 네이티브 메소드의 매개변수, 지역변수 등을 Byte Code로 저장한다.
<br>

### 힙
#### 런타임에 동적으로 할당되는 데이터가 저장되는 영역. 객체나 배열 생성이 여기에 해당함
#### 힙 영역에 생성된 객체와 배열 등은 스택 영역의 변수나 다른 객체의 필드에서 참조한다
#### 참조하는 변수나 필드가 없다면 의미가 없어 GC의 대상이 된다.
#### (또한 힙에 할당된 데이터들은 가비지컬렉터의 대상이 됨. JVM 성능 이슈에서 가장 많이 언급되는 공간임)
### 힙 영역의 사용기간 및 스레드 공유 범위
#### 객체가 더이상 사용되지 않거나 명시적으로 null 선언시
#### GC 대상
#### 모든 스레드에서 공유한다.
<br>

### 메서드 영역
#### JVM이 시작될 때 생성되고, JVM이 읽은 각각의 클래스와 인터페이스에 대한 런타임 상수 풀, 필드 및 메서드 코드, 정적 변수, 메소드의 바이트 코드, 생성자 등을 보관함
### 또한 메서드 영역에는 Runtime Constant Pool 이라고 존재한다.
<br>

#### Runtime Constant Pool이란 메소드 영역에는 포함이 되지만 독자적으로 중요성이 있다.
#### 클래스 파일 또한 여기 테이블에 해당하는 영역이다.
#### 클래스와 인터페이스 상수, 메소드와 필드에 대한 모든 레퍼런스를 저장한다.
#### JVM은 Runtime Constant Pool을 통해서 해당 메소드나 필드의 실제 메모리 상 주소를 찾아 찾조한다.
<br>

### Method Area와 Runtime Constant Pool의 사용 기간과 스레드 공유 범위는
#### JVM 시작 시 생성이 되며, 프로그램 종료시 까지 유지된다.
#### 명시적으로 null 선언 시
#### 모든 스레드에서 공유한다.
<br>

### Execution Engine
### Class Loader를 통해 JVM 내의 런타임 데이터 영역에 배치된 바이트 코드를 실행한다, 이때 Execution Engine은 Java Byte Code를 명령어 단위로 읽어서 실행을 한다.
#### 가비지 컬렉션(Garbage Collection)
##### 자바 이전에는 프로그래머가 모든 프로그램 메모리를 관리했음 하지만, 자바에서는 JVM이 프로그램 메모리를 관리함!
##### JVM은 가비지 컬렉션이라는 프로세스를 통해 메모리를 관리함. 가비지 컬렉션은 자바 프로그램에서 사용되지 않는 메모리를 지속적으로 찾아내서 제거하는 역할을 함.
##### 실행순서 : 참조되지 않은 객체들을 탐색 후 삭제 → 삭제된 객체의 메모리 반환 → 힙 메모리 재사용
